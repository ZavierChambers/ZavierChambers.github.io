<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!--
    Zavier Chambers ‚Äî mobile‚Äëfirst, commented, human‚Äëreadable version
    Static Surf Helper ¬∑ Auto Location ‚Üí pulls local waves, wind, water temp, sunrise/sunset
    100% client‚Äëside (no API keys). Works offline after first load (minus live data).
  -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <title>Static Surf Helper ‚Äì Auto Location</title>
  <style>
    /* ---------- Base + Mobile-first layout ---------- */
    :root{
      --bg:#0b1220; --card:#111a2e; --ink:#e6eefc; --muted:#a5b4d6; --brand:#7aa2ff; --ok:#6ee7b7; --warn:#ffd166;
      --radius:14px; --pad:16px; --gap:12px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif; background:var(--bg); color:var(--ink); margin:0;}
    .wrap{max-width:720px; margin-inline:auto; padding:20px;}
    h1{margin:0 0 12px; font-size:clamp(20px,5vw,28px)}

    /* Card container with comfortable touch targets */
    .card{background:var(--card); padding:var(--pad); margin:12px 0; border-radius:var(--radius); border:1px solid color-mix(in oklab, var(--brand) 25%, transparent)}

    /* Buttons + Inputs: large tap areas for mobile */
    button{appearance:none; width:100%; padding:14px 16px; border-radius:12px; border:1px solid var(--brand); background:#0b1220; color:var(--ink); cursor:pointer; font-weight:700; font-size:1rem}
    button:focus{outline:3px solid var(--brand); outline-offset:2px}
    button:hover{filter:brightness(1.08)}
    .row{display:flex; gap:10px; flex-wrap:wrap}

    /* Results layout: stacked on small, grid on larger screens */
    .results{display:grid; grid-template-columns:1fr; gap:10px}
    @media (min-width:560px){ .results{ grid-template-columns:repeat(2,1fr);} }
    @media (min-width:900px){ .results{ grid-template-columns:repeat(3,1fr);} }

    .result{padding:12px; border-radius:12px; background:rgba(255,255,255,.03); border:1px solid rgba(122,162,255,.18)}
    .result b{display:block; color:var(--muted); font-weight:600; margin-bottom:4px}

    .status{min-height:1.5em; color:var(--muted); margin-top:8px}
    .ok{color:var(--ok)}
    .warn{color:var(--warn)}

    .sub{color:var(--muted); font-size:.9rem}
    .chip{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px dashed rgba(122,162,255,.35)}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üèÑ‚Äç‚ôÇÔ∏è Surf Helper ‚Äî Auto Prefill</h1>
    <div class="sub">Client‚Äëside only ‚Ä¢ Uses <span class="chip">Geolocation</span>, <span class="chip">Open‚ÄëMeteo Marine</span>, <span class="chip">ECMWF (SST)</span>, <span class="chip">Sunrise‚ÄëSunset</span></div>

    <!-- ACTIONS CARD -->
    <section class="card" aria-labelledby="actions-title">
      <h2 id="actions-title" class="sub" style="margin:0 0 8px">1) Pull local conditions</h2>
      <div class="row">
        <button id="getData">Use My Location (Auto‚ÄëFill)</button>
      </div>
      <!-- aria-live makes screen readers announce async updates -->
      <div id="status" class="status" role="status" aria-live="polite"></div>
      <div id="tz" class="sub"></div>
    </section>

    <!-- RESULTS CARD -->
    <section class="card" aria-labelledby="results-title">
      <h2 id="results-title" class="sub" style="margin:0 0 8px">2) Current snapshot (nearest hour)</h2>
      <div class="results">
        <div class="result"><b>üåä Wave Height</b><span id="wave">‚Äî</span></div>
        <div class="result"><b>üå¨ Wind</b><span id="wind">‚Äî</span></div>
        <div class="result"><b>üå° Water Temp</b><span id="water">‚Äî</span></div>
        <div class="result"><b>‚òÄÔ∏è Sunrise</b><span id="sunrise">‚Äî</span></div>
        <div class="result"><b>üåá Sunset</b><span id="sunset">‚Äî</span></div>
        <div class="result"><b>üìç Location</b><span id="loc">‚Äî</span></div>
      </div>
    </section>

    <!-- HOW IT WORKS / HUMAN NOTES -->
    <section class="card">
      <div class="sub"><b>How this works (in human terms)</b></div>
      <ul class="sub" style="margin:8px 0 0 16px; padding:0 0 0 12px">
        <li><b>Geolocation</b>: your browser asks permission and gives us lat/lon. We don‚Äôt send it anywhere except the public APIs you see below.</li>
        <li><b>Nearest hour</b>: APIs return hourly arrays. We pick the timestamp closest to ‚Äúnow‚Äù so numbers feel current.</li>
        <li><b>Units</b>: wave meters ‚Üí feet, wind m/s ‚Üí knots, temperature stays in ¬∞C.</li>
        <li><b>Privacy</b>: everything runs in your browser; no keys, no server.</li>
      </ul>
    </section>
  </div>

  <script>
    // ===== Helper functions (commented, readable) =====
    const $ = (id) => document.getElementById(id);
    const toFeet = (m) => m * 3.28084;         // meters ‚Üí feet
    const msToKts = (ms) => ms * 1.943844;     // meters/second ‚Üí knots

    /** Find index of the time entry closest to now
     *  times: array of ISO timestamps from API (strings)
     */
    function closestHourIndex(times){
      if (!Array.isArray(times) || times.length === 0) return 0;
      const now = Date.now();
      let best = 0, diff = Infinity;
      for (let i=0; i<times.length; i++){
        const t = Date.parse(times[i]);
        const d = Math.abs(t - now);
        if (d < diff){ best = i; diff = d; }
      }
      return best;
    }

    /** Update a result span safely */
    function setText(id, text){ const el = $(id); if (el) el.textContent = text; }

    /** Human‚Äëreadable location: keep it simple with lat/lon (no extra API) */
    function formatLatLon(lat, lon){
      const f = (v,sym) => `${Math.abs(v).toFixed(3)}¬∞ ${v>=0?sym[0]:sym[1]}`;
      return `${f(lat, 'N S')}, ${f(lon, 'E W')}`;
    }

    // ===== API fetchers (Open-Meteo + Sunrise/Sunset) =====
    // Fallback: land weather API for wind if marine returns null
    async function fetchLandWind(lat, lon){
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=wind_speed_10m&timezone=auto&past_hours=24&forecast_hours=24`;
      const r = await fetch(url);
      if (!r.ok) throw new Error(`Forecast wind fetch failed: ${r.status}`);
      return r.json();
    }

    // Air temperature (proxy if SST missing)
    async function fetchAirTemp(lat, lon){
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m&timezone=auto&past_hours=24&forecast_hours=24`;
      const r = await fetch(url);
      if (!r.ok) throw new Error(`Air temp fetch failed: ${r.status}`);
      return r.json();
    }

    async function fetchMarine(lat, lon){
      const url = `https://marine-api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&hourly=wave_height,wave_direction,wave_period,wind_speed_10m,wind_direction_10m&timezone=auto&past_hours=24&forecast_hours=24`;
      const r = await fetch(url);
      if (!r.ok) throw new Error(`Marine fetch failed: ${r.status}`);
      return r.json();
    }

    async function fetchSST(lat, lon){
      // ECMWF sometimes lacks nearshore SST; widen the time window to include past+next 24h
      const url = `https://api.open-meteo.com/v1/ecmwf?latitude=${lat}&longitude=${lon}&hourly=sea_surface_temperature&timezone=auto&past_hours=24&forecast_hours=24`;
      const r = await fetch(url);
      if (!r.ok) throw new Error(`SST fetch failed: ${r.status}`);
      return r.json();
    }

    async function fetchSun(lat, lon){
      const url = `https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lon}&formatted=0`;
      const r = await fetch(url);
      if (!r.ok) throw new Error(`Sun fetch failed: ${r.status}`);
      return r.json();
    }

    // ===== Smart probing helpers for coastal data =====
    function haversineKm(lat1, lon1, lat2, lon2){
      const R=6371, dLat=(lat2-lat1)*Math.PI/180, dLon=(lon2-lon1)*Math.PI/180;
      const a=Math.sin(dLat/2)**2+Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a));
    }

    /** Probe around user's point to find the nearest marine/SST grid cell with data.
     *  We sample a small ring of offsets (~7‚Äì15 km) so inland users still get coastal values.
     */
    async function probeMarineWithFallback(lat, lon){
      const deltas=[0, 0.06, -0.06, 0.12, -0.12, 0.24, -0.24, 0.36, -0.36, 0.5, -0.5]; // ~6‚Äì7km per 0.06¬∞ lat; lon varies with latitude
      const candidates=[];
      for (const dx of deltas){
        for (const dy of deltas){
          candidates.push([lat+dx, lon+dy]);
        }
      }
      let best=null;
      for (const [la,lo] of candidates){
        try{
          const m=await fetchMarine(la,lo);
          const H=m.hourly||{}; const idx=closestHourIndex(H.time||[]);
          const waveM=Array.isArray(H.wave_height)?H.wave_height[idx]:null;
          if (Number.isFinite(waveM)){
            // choose the closest candidate that has waves
            const dist=haversineKm(lat,lon,la,lo);
            if (!best || dist<best.dist){ best={ data:m, dist, lat:la, lon:lo, idx }; }
          }
        }catch{ /* ignore and continue */ }
      }
      return best; // may be null
    }

    async function probeSSTWithFallback(lat, lon){
      const deltas=[0, 0.06, -0.06, 0.12, -0.12, 0.24, -0.24, 0.36, -0.36, 0.5, -0.5];
      const candidates=[]; for (const dx of deltas){ for (const dy of deltas){ candidates.push([lat+dx, lon+dy]); } }
      let best=null;
      for (const [la,lo] of candidates){
        try{
          const s=await fetchSST(la,lo);
          const H=s.hourly||{}; const idx=closestHourIndex(H.time||[]);
          const tC=Array.isArray(H.sea_surface_temperature)?H.sea_surface_temperature[idx]:null;
          if (Number.isFinite(tC)){
            const dist=haversineKm(lat,lon,la,lo);
            if (!best || dist<best.dist){ best={ data:s, dist, lat:la, lon:lo, idx }; }
          }
        }catch{ /* ignore */ }
      }
      return best;
    }

    // ===== Main handler: ask for location ‚Üí fetch ‚Üí fill UI =====
    async function getSurfData(){
      // 1) Get location from the browser
      if(!('geolocation' in navigator)){
        setText('status', 'Geolocation not supported on this device.');
        return;
      }
      setText('status', 'üìç Getting your location‚Ä¶');

      navigator.geolocation.getCurrentPosition(async pos => {
        // IMPORTANT: we round display only ‚Äî keep raw lat/lon for API calls
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        setText('loc', formatLatLon(lat, lon));
        setText('tz', Intl.DateTimeFormat().resolvedOptions().timeZone || '');

        try{
          setText('status', 'üì° Fetching local marine/weather data‚Ä¶');
          // Fetch in parallel; each may succeed/fail independently
          // Try fast path at user's exact location first
          const [marine0, sst0, sun] = await Promise.allSettled([
            fetchMarine(lat, lon),
            fetchSST(lat, lon),
            fetchSun(lat, lon)
          ]);

          // If waves missing, probe nearby coastal grid cells
          let marinePack=null;
          if (marine0.status==='fulfilled'){
            const H=marine0.value.hourly||{}; const idx=closestHourIndex(H.time||[]);
            const waveM=Array.isArray(H.wave_height)?H.wave_height[idx]:null;
            if (Number.isFinite(waveM)){
              marinePack={ data: marine0.value, idx, lat, lon, dist:0 };
            }
          }
          if (!marinePack){
            marinePack = await probeMarineWithFallback(lat, lon);
          }

          // SST fast path, else probe
          let sstPack=null;
          if (sst0.status==='fulfilled'){
            const H2=sst0.value.hourly||{}; const idx2=closestHourIndex(H2.time||[]);
            const tC=Array.isArray(H2.sea_surface_temperature)?H2.sea_surface_temperature[idx2]:null;
            if (Number.isFinite(tC)) sstPack={ data: sst0.value, idx: idx2, lat, lon, dist:0 };
          }
          if (!sstPack){
            sstPack = await probeSSTWithFallback(lat, lon);
          }

          // 2) Marine ‚Üí waves & wind (nearest hour)
          let waveShown = false, windShown = false;
          if (marinePack){
            const H = marinePack.data.hourly || {};
            const i = marinePack.idx;
            const waveM = Array.isArray(H.wave_height) ? H.wave_height[i] : null;
            const windMS = Array.isArray(H.wind_speed_10m) ? H.wind_speed_10m[i] : null;
            if (Number.isFinite(waveM)){ setText('wave', `${toFeet(waveM).toFixed(1)} ft`); waveShown = true; }
            if (Number.isFinite(windMS)){ setText('wind', `${msToKts(windMS).toFixed(1)} kn`); windShown = true; }
            if (marinePack.dist>0 && waveShown){
              // Let user know we snapped to a nearby coastal grid silently (subtle hint in status)
              setText('status', `‚úÖ Updated. (Closest hour) ¬∑ used nearest coastal cell ~${Math.round(marinePack.dist)} km`);
            }
          }
          if (!windShown){
            try{
              const land = await fetchLandWind(lat, lon);
              const Hf = land.hourly || {};
              const idxf = closestHourIndex(Hf.time || []);
              const windMS2 = Array.isArray(Hf.wind_speed_10m) ? Hf.wind_speed_10m[idxf] : null;
              if (Number.isFinite(windMS2)){ setText('wind', `${msToKts(windMS2).toFixed(1)} kn`); windShown = true; }
            }catch{}
          }
          if (!waveShown) setText('wave', '‚Äî'); // No nearby marine grid found (try moving closer to coastline)
          if (!windShown) setText('wind', '‚Äî');

          // 3) Sea Surface Temperature (¬∞C)
          if (sstPack){
            const H2 = sstPack.data.hourly || {};
            const i2 = sstPack.idx;
            const tC = Array.isArray(H2.sea_surface_temperature) ? H2.sea_surface_temperature[i2] : null;
            setText('water', Number.isFinite(tC) ? `${tC.toFixed(1)} ¬∞C` : '‚Äî');
          } else {
            // SST missing ‚Äî try air temperature as a labeled proxy
            try{
              const air = await fetchAirTemp(lat, lon);
              const Ha = air.hourly || {}; const ia = closestHourIndex(Ha.time || []);
              const t2m = Array.isArray(Ha.temperature_2m) ? Ha.temperature_2m[ia] : null;
              setText('water', Number.isFinite(t2m) ? `${t2m.toFixed(1)} ¬∞C (air)` : '‚Äî');
            }catch{ setText('water', '‚Äî'); }
          }

          // 4) Sunrise/Sunset
          if (sun.status === 'fulfilled' && sun.value.status === 'OK'){
            const r = sun.value.results;
            const sunrise = new Date(r.sunrise);
            const sunset = new Date(r.sunset);
            setText('sunrise', sunrise.toLocaleTimeString());
            setText('sunset', sunset.toLocaleTimeString());
          } else {
            setText('sunrise', '‚Äî');
            setText('sunset', '‚Äî');
          }

          setText('status', '‚úÖ Updated. (Closest hour)');
          // Debug hint for you during testing ‚Äî comment out if noisy
          console.debug('Marine/SST/sun processed:', { waveText: $('wave').textContent, windText: $('wind').textContent, waterText: $('water').textContent });
        } catch (e){
          console.error(e);
          setText('status', `‚ö†Ô∏è Error fetching data: ${e.message}`);
        }
      }, err => {
        // Location denied or unavailable
        setText('status', `‚ùå Location error: ${err.message}`);
      }, { enableHighAccuracy:true, timeout:12000, maximumAge:60000 });
    }

    // Wire the button, and make it easy for mobile users
    document.getElementById('getData').addEventListener('click', getSurfData);

    // Optional: auto‚Äëprompt shortly after load to reduce taps
    setTimeout(()=>{ /* comment this in if you want auto-run: getSurfData(); */ }, 600);
  </script>
</body>
</html>
