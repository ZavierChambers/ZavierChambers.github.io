<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Maze Chase — Static (IT Guy)</title>
<style>
  :root{
    --ui:#ebebf5;
    --hi:#78dc8c;
    --warn:#eb4646;
    --floor:#16161e;
    --player:#c8dcff;
    --chaser:#ff7878;
    --chaser-sleep:#b45050;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:#0e0e14;color:var(--ui);font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace}
  #wrap{display:grid;place-items:center;height:100%}
  canvas{display:block;max-width:100vw;max-height:100vh;aspect-ratio:16/10;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.45)}
  .hint{position:fixed;right:10px;bottom:8px;opacity:.7;font-size:12px}
  .legend{position:fixed;left:10px;bottom:8px;opacity:.85;font-size:12px}
  .sr{position:absolute;left:-9999px}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="960" height="600" aria-label="Maze Chase game area"></canvas>
</div>
<div class="legend">WASD/Arrows to move • Enter/Space select • Esc back</div>
<div class="hint">F1: BG • F2: Wall</div>

<script>
(() => {
  "use strict";

  // ---------------- Config (mirrors the Python version) ----------------
  const WIDTH=960, HEIGHT=600, TILE=22, FPS=60;

  const PRESET_BG = [
    [14,14,20], [0,0,0], [12,18,32], [18,18,18], [28,24,36], [8,16,24], [24,24,40]
  ];
  const PRESET_WALL = [
    [40,40,55], [60,60,80], [30,30,45], [70,30,30], [30,70,30], [30,50,70], [80,70,30]
  ];

  // Colors used directly while drawing:
  const COL = {
    UI:        [235,235,245],
    HI:        [120,220,140],
    WARN:      [235,70,70],
    FLOOR:     [22,22,30],
    EXIT:      [120,220,140],
    PLAYER:    [200,220,255],
    CHASER:    [255,120,120],
    CHASER_ZZ: [180, 80, 80]
  };

  // ---------------- Helpers ----------------
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const now = () => performance.now();

  function makeRgba(rgb, a=1){
    return `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
  }

  // Random with seed for reproducible mazes each round
  function mulberry32(seed) {
    let t = seed >>> 0;
    return function() {
      t += 0x6D2B79F5;
      let r = Math.imul(t ^ (t >>> 15), 1 | t);
      r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
      return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
    };
  }

  // ---------------- Maze generation (recursive backtracker + loops) ----------------
  function generatePerfectMaze(cols, rows, rng){
    const grid = Array.from({length:rows}, ()=>Array(cols).fill(true)); // true=wall
    const stack = [[1,1]];
    grid[1][1] = false;
    const dirs = [[2,0],[-2,0],[0,2],[0,-2]];
    while (stack.length){
      const [x,y] = stack[stack.length-1];
      const nbrs = [];
      for (const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if (1<=nx && nx<cols-1 && 1<=ny && ny<rows-1 && grid[ny][nx]){
          nbrs.push([nx,ny, dx/2, dy/2]);
        }
      }
      if (nbrs.length){
        const [nx,ny,hx,hy] = nbrs[(rng()*nbrs.length)|0];
        grid[y+hy][x+hx] = false; // carve between
        grid[ny][nx] = false;     // carve target
        stack.push([nx,ny]);
      } else {
        stack.pop();
      }
    }
    grid[1][1] = false;
    grid[rows-2][cols-2] = false;
    return grid;
  }

  function carveLoops(grid, loopFactor, rng){
    const rows = grid.length, cols = grid[0].length;
    const cands = [];
    for (let y=1; y<rows-1; y++){
      for (let x=1; x<cols-1; x++){
        if (grid[y][x]){
          if (!grid[y-1][x] && !grid[y+1][x]) cands.push([x,y]);
          else if (!grid[y][x-1] && !grid[y][x+1]) cands.push([x,y]);
        }
      }
    }
    // shuffle (Fisher-Yates)
    for (let i=cands.length-1;i>0;i--){
      const j = (rng()*(i+1))|0;
      [cands[i], cands[j]] = [cands[j], cands[i]];
    }
    const carveCount = Math.floor(cands.length * loopFactor);
    for (let i=0;i<carveCount;i++){
      const [cx,cy] = cands[i];
      grid[cy][cx] = false;
    }
  }

  function generateMazeWithLoops(cols, rows, loopFactor, rng){
    const g = generatePerfectMaze(cols, rows, rng);
    carveLoops(g, loopFactor, rng);
    return g;
  }

  // ---------------- Pathing: neighbors, BFS distances, A* ----------------
  function neighbors4(grid, x, y){
    const rs = [];
    const rows = grid.length, cols = grid[0].length;
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for (const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy;
      if (0<=ny && ny<rows && 0<=nx && nx<cols && !grid[ny][nx]) rs.push([nx,ny]);
    }
    return rs;
  }

  function bfsDistances(grid, start){
    const dist = new Map();
    const q = [start];
    dist.set(start.join(','), 0);
    while (q.length){
      const [x,y] = q.shift();
      const d0 = dist.get(`${x},${y}`);
      for (const [nx,ny] of neighbors4(grid, x, y)){
        const key = `${nx},${ny}`;
        if (!dist.has(key)){
          dist.set(key, d0+1);
          q.push([nx,ny]);
        }
      }
    }
    return dist;
  }

  function randomFarExitCell(grid, start, minFraction, rng){
    const dist = bfsDistances(grid, start);
    if (dist.size === 0) return start;
    let maxd = 0;
    for (const d of dist.values()) maxd = Math.max(maxd, d);
    const threshold = Math.floor(maxd * minFraction);
    const cands = [];
    for (const [key, d] of dist.entries()){
      if (d >= threshold) cands.push(key.split(',').map(Number));
    }
    const pool = cands.length ? cands : [...dist.entries()]
      .sort((a,b)=>b[1]-a[1])[0][0].split(',').map(Number);
    if (Array.isArray(pool[0])) return pool[(rng()*pool.length)|0];
    return pool;
  }

  function astar(grid, start, goal){
    const [gx,gy] = goal;
    const key = (x,y)=>`${x},${y}`;
    const h = (x,y)=>Math.abs(x-gx)+Math.abs(y-gy);

    const open = new MinHeap((a,b)=>a.f-b.f);
    open.push({x:start[0], y:start[1], g:0, f:h(start[0],start[1])});
    const parent = new Map();
    const gscore = new Map([[key(...start), 0]]);

    while (!open.empty()){
      const cur = open.pop();
      if (cur.x===gx && cur.y===gy){
        const path = [[cur.x,cur.y]];
        let p = parent.get(key(cur.x,cur.y));
        while (p){
          path.push([p.x,p.y]);
          p = parent.get(key(p.x,p.y));
        }
        path.reverse();
        return path;
      }
      for (const [nx,ny] of neighbors4(grid, cur.x, cur.y)){
        const ng = cur.g + 1;
        const k = key(nx,ny);
        if (!gscore.has(k) || ng < gscore.get(k)){
          gscore.set(k, ng);
          parent.set(k, {x:cur.x, y:cur.y});
          open.push({x:nx, y:ny, g:ng, f:ng + h(nx,ny)});
        }
      }
    }
    return [];
  }

  // Simple binary heap for A*
  class MinHeap{
    constructor(cmp){this.cmp=cmp;this.a=[];}
    empty(){return this.a.length===0;}
    push(x){this.a.push(x);this._up(this.a.length-1);}
    pop(){
      const a=this.a; if(!a.length) return;
      const top=a[0], last=a.pop();
      if (a.length){a[0]=last; this._down(0);}
      return top;
    }
    _up(i){
      const {a,cmp}=this;const x=a[i];
      while(i){
        const p=(i-1)>>1;
        if (cmp(x,a[p])>=0) break;
        a[i]=a[p]; i=p;
      }
      a[i]=x;
    }
    _down(i){
      const {a,cmp}=this; const n=a.length; const x=a[i];
      while(true){
        let l=i*2+1, r=l+1, j=i;
        if (l<n && cmp(a[l],a[j])<0) j=l;
        if (r<n && cmp(a[r],a[j])<0) j=r;
        if (j===i) break;
        a[i]=a[j]; i=j;
      }
      a[i]=x;
    }
  }

  // ---------------- Game State ----------------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const GameState = {
    MENU: 'MENU',
    SETTINGS: 'SETTINGS',
    PLAY: 'PLAY',
    OVER: 'OVER'
  };

  const LEVEL_SIZES = [[79,51],[95,61],[111,71],[127,81]]; // scales up with rounds

  const game = {
    state: GameState.MENU,
    menuIndex: 0,
    round: 0,

    loopiness: 0.25,     // 0..1 mapped to 0..0.18 in maze carving
    playerSpeed: 2.4,
    enemySpeed: 2.2,

    CHASE_DELAY: 10.0,
    REPLAN_FRAMES: 5,

    bgIdx: 0,
    wallIdx: 0,
    colBg: PRESET_BG[0],
    colWall: PRESET_WALL[0],

    grid: null,
    cols: 0,
    rows: 0,

    worldW: 0,
    worldH: 0,
    camx: 0,
    camy: 0,

    player: null,
    chaser: null,
    exitRect: {x:0,y:0,w:Math.floor(TILE/1.5),h:Math.floor(TILE/1.5)},

    startCountdown: 0,
    countdown: 0,
    awake: false,
    canHurt: false,
    wakeGrace: 0.9,
    graceTimer: 0.0,
    replanFrames: 0,
    pathPixels: [],

    keys: new Set(),
  };

  class Entity {
    constructor(x,y,speed,color){
      this.x=x; this.y=y; this.w=TILE*0.8; this.h=TILE*0.8;
      this.speed=speed; this.color=color;
    }
    rect(){ return {x:this.x|0, y:this.y|0, w:this.w|0, h:this.h|0}; }
  }

  function sizeForRound(r){
    const idx = Math.min(r-1, LEVEL_SIZES.length-1);
    return LEVEL_SIZES[idx];
  }

  function cellCenter(cell){ // pixel center with slight inset to match styling
    const [cx,cy] = cell;
    return [ (cx*TILE + TILE*0.1)|0, (cy*TILE + TILE*0.1)|0 ];
  }

  function gridCell(x,y){ return [(x/TILE)|0, (y/TILE)|0]; }

  function passable(grid, px, py){
    const cx = (px/TILE)|0, cy=(py/TILE)|0;
    if (cy<0 || cy>=grid.length || cx<0 || cx>=grid[0].length) return false;
    return !grid[cy][cx];
  }

  function moveWithCollide(ent, nx, ny){
    const g = game.grid;
    if (passable(g, nx, ny)){ ent.x=nx; ent.y=ny; return; }
    if (passable(g, nx, ent.y)) ent.x=nx;
    if (passable(g, ent.x, ny)) ent.y=ny;
  }

  // ---------------- Draw routines ----------------
  function clearScreen(rgb){ ctx.fillStyle = makeRgba(rgb); ctx.fillRect(0,0,WIDTH,HEIGHT); }

  function drawWorld(){
    clearScreen(game.colBg);
    // tiles
    for (let y=0; y<game.rows; y++){
      const ry = y*TILE - (game.camy|0);
      if (ry>HEIGHT || ry+TILE<0) continue;
      for (let x=0; x<game.cols; x++){
        const rx = x*TILE - (game.camx|0);
        if (rx>WIDTH || rx+TILE<0) continue;
        const wall = game.grid[y][x];
        ctx.fillStyle = wall ? makeRgba(game.colWall) : makeRgba(COL.FLOOR);
        ctx.fillRect(rx, ry, TILE, TILE);
      }
    }
    // exit
    ctx.fillStyle = makeRgba(COL.EXIT);
    const ex = (game.exitRect.x - game.camx)|0, ey=(game.exitRect.y - game.camy)|0;
    roundRect(ctx, ex, ey, game.exitRect.w, game.exitRect.h, 4, true, false);
  }

  function drawEntities(){
    const px = (game.player.x - game.camx)|0, py=(game.player.y - game.camy)|0;
    ctx.fillStyle = makeRgba(COL.PLAYER);
    roundRect(ctx, px, py, game.player.w, game.player.h, 6, true, false);

    const cx = (game.chaser.x - game.camx)|0, cy=(game.chaser.y - game.camy)|0;
    ctx.fillStyle = game.awake ? makeRgba(COL.CHASER) : makeRgba(COL.CHASER_ZZ);
    roundRect(ctx, cx, cy, game.chaser.w, game.chaser.h, 6, true, false);
  }

  function drawHUD(){
    ctx.font = "20px Consolas, monospace";
    ctx.fillStyle = makeRgba(COL.UI);
    ctx.fillText(`Round ${game.round}`, 10, 22);

    if (game.startCountdown > 0){
      const s = Math.max(0, Math.ceil(game.startCountdown));
      drawCenteredOverlay(`${s}`);
    }
    if (!game.awake){
      ctx.fillStyle = makeRgba(COL.WARN);
      ctx.fillText(`Chaser wakes in: ${Math.max(0, Math.ceil(game.countdown))}`, 160, 22);
    }
  }

  function drawCenteredOverlay(text){
    ctx.font = "48px Consolas, monospace";
    const tw = ctx.measureText(text).width;
    const th = 48;
    const bgW = tw+24, bgH=th+24;
    ctx.fillStyle = "rgba(0,0,0,.5)";
    ctx.fillRect((WIDTH-bgW)/2, (HEIGHT-bgH)/2, bgW, bgH);
    ctx.fillStyle = makeRgba(COL.UI);
    ctx.fillText(text, (WIDTH-tw)/2, (HEIGHT+th*0.35)/2);
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    if (w<2*r) r=w/2; if (h<2*r) r=h/2;
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // ---------------- Menus ----------------
  const menuItems = ["Play","Settings","Quit"];
  function menuLoopStep(){
    clearScreen(game.colBg);
    ctx.fillStyle = makeRgba(COL.UI);
    ctx.font = "48px Consolas, monospace";
    const title = "Maze Chase — Core";
    const tw = ctx.measureText(title).width;
    ctx.fillText(title, (WIDTH-tw)/2, 140);

    ctx.font = "20px Consolas, monospace";
    for (let i=0;i<menuItems.length;i++){
      ctx.fillStyle = i===game.menuIndex ? makeRgba(COL.HI) : makeRgba(COL.UI);
      const t = menuItems[i], w = ctx.measureText(t).width;
      ctx.fillText(t, (WIDTH-w)/2, 260 + i*36);
    }
  }

  function settingsLoopStep(){
    clearScreen(game.colBg);
    ctx.fillStyle = makeRgba(COL.UI);
    ctx.font = "48px Consolas, monospace";
    const title = "Settings";
    const tw = ctx.measureText(title).width;
    ctx.fillText(title, (WIDTH-tw)/2, 110);

    const items = [
      `Background Color: #${game.bgIdx+1}/${PRESET_BG.length}`,
      `Wall Color:       #${game.wallIdx+1}/${PRESET_WALL.length}`,
      `Loopiness (cycles): ${game.loopiness.toFixed(2)}`,
      `Player Speed:       ${game.playerSpeed.toFixed(2)}`,
      `Enemy Speed:        ${game.enemySpeed.toFixed(2)}`,
      "Back"
    ];
    ctx.font = "20px Consolas, monospace";
    for (let i=0;i<items.length;i++){
      ctx.fillStyle = i===settingsIndex ? makeRgba(COL.HI) : makeRgba(COL.UI);
      const w = ctx.measureText(items[i]).width;
      ctx.fillText(items[i], (WIDTH-w)/2, 240 + i*34);
    }
    const hint = "↑/↓ select, ←/→ adjust, Enter to confirm, Esc to back";
    ctx.fillStyle = "rgba(180,180,200,.9)";
    const hw = ctx.measureText(hint).width;
    ctx.fillText(hint, (WIDTH-hw)/2, HEIGHT-40);
  }

  let settingsIndex = 0;

  // ---------------- Game Flow ----------------
  function startRound(){
    game.round += 1;

    const effEnemySpeed = game.enemySpeed + 0.05 * Math.max(0, game.round-1);
    const effChaseDelay = Math.max(4.0, game.CHASE_DELAY - 0.3 * Math.max(0, game.round-1));

    const [cols, rows] = sizeForRound(game.round);

    // seed by time ^ round to vary
    const seed = (Date.now() ^ (game.round * 7331)) >>> 0;
    const rng = mulberry32(seed);
    const loopFactor = game.loopiness * 0.18;

    game.grid = generateMazeWithLoops(cols, rows, loopFactor, rng);
    game.cols=cols; game.rows=rows;
    game.worldW = cols*TILE; game.worldH = rows*TILE;

    game.player = new Entity(...cellCenter([1,1]), game.playerSpeed, COL.PLAYER);
    const exitCell = randomFarExitCell(game.grid, [1,1], 0.72, rng);
    const [exx,exy] = cellCenter(exitCell);
    game.exitRect.x = (exx - (game.exitRect.w/2))|0;
    game.exitRect.y = (exy - (game.exitRect.h/2))|0;

    game.chaser = new Entity(...cellCenter([1,1]), effEnemySpeed, COL.CHASER);

    game.awake=false;
    game.countdown=effChaseDelay;
    game.startCountdown=3.0;
    game.canHurt=false;
    game.graceTimer=0.0;
    game.replanFrames=game.REPLAN_FRAMES;
    game.pathPixels.length=0;
    game.camx=0; game.camy=0;
  }

  function roundClearScreenStep(){
    clearScreen(game.colBg);
    ctx.fillStyle = makeRgba(COL.UI);
    ctx.font = "48px Consolas, monospace";
    const t = `Round ${game.round} complete!`;
    const tw = ctx.measureText(t).width;
    ctx.fillText(t, (WIDTH-tw)/2, HEIGHT/2 - 40);

    ctx.font = "20px Consolas, monospace";
    const hint = "Press any key to start the next round";
    const hw = ctx.measureText(hint).width;
    ctx.fillStyle = "rgba(200,200,210,.95)";
    ctx.fillText(hint, (WIDTH-hw)/2, HEIGHT/2 + 20);
  }

  function gameOverStep(){
    clearScreen(game.colBg);
    ctx.fillStyle = makeRgba(COL.UI);
    ctx.font = "48px Consolas, monospace";
    const t = "Game Over";
    const tw = ctx.measureText(t).width;
    ctx.fillText(t, (WIDTH-tw)/2, HEIGHT/2 - 40);

    ctx.font = "20px Consolas, monospace";
    const hint = "Press Enter to return to menu";
    const hw = ctx.measureText(hint).width;
    ctx.fillStyle = "rgba(200,200,210,.95)";
    ctx.fillText(hint, (WIDTH-hw)/2, HEIGHT/2 + 20);
  }

  let interstitial = null; // "ROUND_CLEAR"
  let lastTime = now();
  let acc = 0, step = 1/ FPS;

  function loop(){
    const t = now();
    let dt = (t - lastTime)/1000;
    if (dt>0.1) dt=0.1;
    lastTime = t;

    switch (game.state){
      case GameState.MENU: menuLoopStep(); break;
      case GameState.SETTINGS: settingsLoopStep(); break;
      case GameState.PLAY:
        acc += dt;
        while (acc >= step){
          tick(step);
          acc -= step;
        }
        drawWorld();
        drawEntities();
        drawHUD();
        if (interstitial==="ROUND_CLEAR"){ roundClearScreenStep(); }
        else if (interstitial==="GAME_OVER"){ gameOverStep(); }
        break;
    }
    requestAnimationFrame(loop);
  }

  function tick(dt){
    if (interstitial){
      // waiting for key/mouse to continue
      return;
    }

    // Input & movement
    let vx=0, vy=0;
    if (game.startCountdown <= 0){
      if (game.keys.has("ArrowLeft") || game.keys.has("a")) vx -= game.player.speed;
      if (game.keys.has("ArrowRight")|| game.keys.has("d")) vx += game.player.speed;
      if (game.keys.has("ArrowUp")   || game.keys.has("w")) vy -= game.player.speed;
      if (game.keys.has("ArrowDown") || game.keys.has("s")) vy += game.player.speed;
      if (vx && vy){ vx*=0.7071; vy*=0.7071; }
      moveWithCollide(game.player, game.player.x + vx, game.player.y + vy);
    }

    // Camera follow
    const tx = game.player.x - WIDTH/2;
    const ty = game.player.y - HEIGHT/2;
    game.camx += (tx - game.camx)*0.12;
    game.camy += (ty - game.camy)*0.12;
    game.camx = clamp(game.camx, 0, game.worldW - WIDTH);
    game.camy = clamp(game.camy, 0, game.worldH - HEIGHT);

    // Round start lock
    if (game.startCountdown > 0){
      game.startCountdown -= dt;
      if (game.startCountdown < 0) game.startCountdown = 0;
    }

    // Wake logic
    if (!game.awake){
      if (game.startCountdown <= 0){
        game.countdown -= dt;
      }
      if (game.countdown <= 0){
        game.awake = true; game.canHurt = false;
        game.graceTimer = game.wakeGrace;
        // nudge chaser if overlapping at wake
        const pc = gridCell(game.player.x, game.player.y);
        const cc = gridCell(game.chaser.x, game.chaser.y);
        if (pc[0]===cc[0] && pc[1]===cc[1]){
          for (const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
            const nx=cc[0]+dx, ny=cc[1]+dy;
            if (0<=nx && nx<game.cols && 0<=ny && ny<game.rows && !game.grid[ny][nx]){
              const [cx,cy] = cellCenter([nx,ny]);
              game.chaser.x=cx; game.chaser.y=cy; break;
            }
          }
        }
      }
    } else {
      if (!game.canHurt){
        game.graceTimer -= dt;
        if (game.graceTimer <= 0) game.canHurt = true;
      }
    }

    // Chaser AI: replan with A*, then follow pixel waypoints
    if (game.awake){
      game.replanFrames -= 1;
      if (game.replanFrames <= 0 || game.pathPixels.length===0){
        game.replanFrames = game.REPLAN_FRAMES;
        const pc = gridCell(game.player.x, game.player.y);
        const cc = gridCell(game.chaser.x, game.chaser.y);
        const path = astar(game.grid, cc, pc);
        game.pathPixels = path.slice(1, 8).map(cellCenter);
      }

      if (game.pathPixels.length){
        const [txp, typ] = game.pathPixels[0];
        const dx = txp - game.chaser.x, dy = typ - game.chaser.y;
        const d = Math.hypot(dx,dy) || 1;
        const step = game.chaser.speed;
        moveWithCollide(game.chaser, game.chaser.x + (dx/d)*step, game.chaser.y + (dy/d)*step);
        if (Math.abs(game.chaser.x - txp) < 1 && Math.abs(game.chaser.y - typ) < 1){
          game.pathPixels.shift();
        }
      }

      // Close pursuit "push"
      const pcx = game.player.x + game.player.w*0.5;
      const pcy = game.player.y + game.player.h*0.5;
      const ccx = game.chaser.x + game.chaser.w*0.5;
      const ccy = game.chaser.y + game.chaser.h*0.5;
      const ddx = pcx - ccx, ddy = pcy - ccy;
      const dist = Math.hypot(ddx,ddy) || 1;
      const closeRange = 3*TILE;
      if (dist < closeRange){
        const push = game.chaser.speed * 1.5;
        moveWithCollide(game.chaser, game.chaser.x + (ddx/dist)*push, game.chaser.y + (ddy/dist)*push);
      }
    }

    // Win?
    if (rectsOverlap(
      {x:game.player.x, y:game.player.y, w:game.player.w, h:game.player.h},
      game.exitRect
    )){
      interstitial = "ROUND_CLEAR";
      // wait for any key to continue
    }

    // Lose?
    if (game.awake && game.canHurt){
      const pr = {x:game.player.x, y:game.player.y, w:game.player.w, h:game.player.h};
      const cr = {x:game.chaser.x, y:game.chaser.y, w:game.chaser.w, h:game.chaser.h};
      const pcx = game.player.x + game.player.w*0.5;
      const pcy = game.player.y + game.player.h*0.5;
      const ccx = game.chaser.x + game.chaser.w*0.5;
      const ccy = game.chaser.y + game.chaser.h*0.5;
      const dist = Math.hypot(pcx-ccx, pcy-ccy);
      const killDist = Math.min(game.player.w, game.chaser.w) * 0.44;
      if (rectsOverlap(pr, cr) || dist <= killDist){
        interstitial = "GAME_OVER";
      }
    }
  }

  function rectsOverlap(a,b){
    return (a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y);
  }

  // ---------------- Input ----------------
  window.addEventListener('keydown', (e)=>{
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
    game.keys.add(e.key);
    if (game.state === GameState.MENU){
      if (e.key==="ArrowUp" || e.key==="w") game.menuIndex = (game.menuIndex-1+menuItems.length)%menuItems.length;
      if (e.key==="ArrowDown"|| e.key==="s") game.menuIndex = (game.menuIndex+1)%menuItems.length;
      if (e.key==="Enter" || e.key===" "){
        if (game.menuIndex===0){ game.state=GameState.PLAY; interstitial=null; game.round=0; startRound(); }
        else if (game.menuIndex===1){ game.state=GameState.SETTINGS; settingsIndex=0; }
        else if (game.menuIndex===2){ /* "Quit": in web, go back to menu splash */ }
      }
    } else if (game.state === GameState.SETTINGS){
      if (e.key==="ArrowUp" || e.key==="w") settingsIndex = (settingsIndex-1+6)%6;
      if (e.key==="ArrowDown"|| e.key==="s") settingsIndex = (settingsIndex+1)%6;
      if (e.key==="ArrowLeft"|| e.key==="a"){
        if (settingsIndex===0){ game.bgIdx=(game.bgIdx-1+PRESET_BG.length)%PRESET_BG.length; game.colBg=PRESET_BG[game.bgIdx]; }
        else if (settingsIndex===1){ game.wallIdx=(game.wallIdx-1+PRESET_WALL.length)%PRESET_WALL.length; game.colWall=PRESET_WALL[game.wallIdx]; }
        else if (settingsIndex===2){ game.loopiness = clamp(game.loopiness-0.05,0,1); }
        else if (settingsIndex===3){ game.playerSpeed = clamp(game.playerSpeed-0.1,1.2,5); }
        else if (settingsIndex===4){ game.enemySpeed  = clamp(game.enemySpeed -0.1,1.0,5); }
      }
      if (e.key==="ArrowRight"|| e.key==="d"){
        if (settingsIndex===0){ game.bgIdx=(game.bgIdx+1)%PRESET_BG.length; game.colBg=PRESET_BG[game.bgIdx]; }
        else if (settingsIndex===1){ game.wallIdx=(game.wallIdx+1)%PRESET_WALL.length; game.colWall=PRESET_WALL[game.wallIdx]; }
        else if (settingsIndex===2){ game.loopiness = clamp(game.loopiness+0.05,0,1); }
        else if (settingsIndex===3){ game.playerSpeed = clamp(game.playerSpeed+0.1,1.2,5); }
        else if (settingsIndex===4){ game.enemySpeed  = clamp(game.enemySpeed +0.1,1.0,5); }
      }
      if (e.key==="Enter" || e.key===" " || e.key==="Escape"){ game.state=GameState.MENU; }
    } else if (game.state === GameState.PLAY){
      if (e.key==="Escape"){ game.state=GameState.MENU; }
      if (e.key==="F1"){ game.bgIdx=(game.bgIdx+1)%PRESET_BG.length; game.colBg=PRESET_BG[game.bgIdx]; }
      if (e.key==="F2"){ game.wallIdx=(game.wallIdx+1)%PRESET_WALL.length; game.colWall=PRESET_WALL[game.wallIdx]; }

      if (interstitial==="ROUND_CLEAR"){
        // Any press continues to the next round
        interstitial=null; startRound();
      } else if (interstitial==="GAME_OVER"){
        if (e.key==="Enter" || e.key===" "){
          interstitial=null; game.state=GameState.MENU;
        }
      }
    }
  });
  window.addEventListener('keyup', (e)=>{ game.keys.delete(e.key); });

  // Kick off render loop
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
